"""
Backtest picks generated by historical_picks_runner.

Supports two modes:
A) Picks contain odds (Pro-Lite, default)
B) Picks require odds from snapshots (Elite / future)

Mode is auto-detected.
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Tuple

import pandas as pd


# ---------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------

def _find_score_cols(df: pd.DataFrame) -> Tuple[str, str]:
    candidates = [
        ("home_score", "away_score"),
        ("home_points", "away_points"),
        ("pts_home", "pts_away"),
        ("home_team_score", "away_team_score"),
    ]
    for h, a in candidates:
        if h in df.columns and a in df.columns:
            return h, a
    raise RuntimeError(
        "[picks_backtest] Could not find home/away score columns. "
        f"Available: {list(df.columns)}"
    )


def _normalize_picks(df: pd.DataFrame) -> Tuple[pd.DataFrame, dict]:
    audit = {"rows": len(df), "mode": None, "inferred": {}}

    # merge_key
    if "merge_key" not in df.columns:
        if {"home_team", "away_team", "game_date"} <= set(df.columns):
            df["merge_key"] = (
                df["home_team"].str.lower()
                + "__"
                + df["away_team"].str.lower()
                + "__"
                + df["game_date"].astype(str)
            )
            audit["inferred"]["merge_key"] = "from teams + date"
        else:
            raise RuntimeError("[picks_backtest] Cannot infer merge_key")

    # bet_side
    if "bet_side" not in df.columns:
        for c in ["side", "pick_side"]:
            if c in df.columns:
                df["bet_side"] = df[c].str.upper()
                audit["inferred"]["bet_side"] = f"from {c}"
                break
        else:
            raise RuntimeError("[picks_backtest] Missing bet_side")

    df["bet_side"] = df["bet_side"].str.upper()
    df = df[df["bet_side"].isin(["HOME", "AWAY"])]

    # odds handling (CRITICAL FIX)
    if "odds" in df.columns:
        df["odds"] = df["odds"].astype(float)
        audit["mode"] = "embedded_odds"
    else:
        audit["mode"] = "snapshot_required"

    return df, audit


# ---------------------------------------------------------------------
# Core
# ---------------------------------------------------------------------

def backtest_picks(picks_df, history_df, stake: float):
    picks_df, audit = _normalize_picks(picks_df)

    if audit["mode"] != "embedded_odds":
        raise RuntimeError(
            "[picks_backtest] Picks do not contain odds. "
            "Snapshot-based resolution not enabled in Pro-Lite."
        )

    joined = picks_df.merge(
        history_df,
        on="merge_key",
        how="left",
        validate="many_to_one",
        indicator=True,
    )

    joined = joined[joined["_merge"] == "both"].drop(columns="_merge")
    if joined.empty:
        raise RuntimeError("[picks_backtest] All picks dropped after join")

    home_score, away_score = _find_score_cols(joined)
    joined["home_win"] = (joined[home_score] > joined[away_score]).astype(int)

    joined["result"] = joined.apply(
        lambda r: r["home_win"] if r["bet_side"] == "HOME" else 1 - r["home_win"],
        axis=1,
    )

    joined["stake"] = stake
    joined["pnl"] = joined.apply(
        lambda r: (r["odds"] - 1) * stake if r["result"] == 1 else -stake,
        axis=1,
    )

    audit.update({
        "resolved_bets": len(joined),
        "total_pnl": float(joined["pnl"].sum()),
        "roi": float(joined["pnl"].sum() / joined["stake"].sum()),
    })

    return joined, audit


# ---------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--picks-dir", required=True)
    ap.add_argument("--pattern", default="picks_*.csv")
    ap.add_argument("--history", required=True)
    ap.add_argument("--snapshot-dir", default=None)  # accepted for forward compatibility
    ap.add_argument("--out-dir", required=True)
    ap.add_argument("--stake", type=float, default=1.0)
    args = ap.parse_args()

    pick_files = list(Path(args.picks_dir).glob(args.pattern))
    if not pick_files:
        raise RuntimeError(f"[picks_backtest] No pick files matched {args.pattern}")

    picks = pd.concat([pd.read_csv(p) for p in pick_files], ignore_index=True)
    history = pd.read_csv(args.history)

    joined, audit = backtest_picks(picks, history, args.stake)

    out = Path(args.out_dir)
    out.mkdir(exist_ok=True, parents=True)

    joined.to_csv(out / "picks_backtest.csv", index=False)
    (out / "picks_backtest_audit.json").write_text(json.dumps(audit, indent=2))

    summary = pd.DataFrame([{
        "bets": len(joined),
        "wins": int((joined["result"] == 1).sum()),
        "roi": audit["roi"],
        "total_pnl": audit["total_pnl"],
    }])
    summary.to_csv(out / "picks_backtest_summary.csv", index=False)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
